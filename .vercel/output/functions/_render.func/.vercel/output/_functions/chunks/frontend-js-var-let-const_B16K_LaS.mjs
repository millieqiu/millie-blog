import { f as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro_CAHbMDKa.mjs';

const html = "<p>會想寫這篇文的原因，是某天跟同事聊天的過程中，聊到在 JS 宣告變數時幾乎很少用到 <code>var</code>，雖然知道這種宣告變數的方式跟 <code>let</code>、<code>const</code> 有差異，具體而言我卻說不出為什麼，只依稀記得跟作用域有關…。</p>\n<p>為了往後討論這個問題時，都能像個 JS 大師般侃侃而談，我回家後立刻將這題好好鑽研一番，也順便做了筆記，如果以後忘記了隨時都能拿出來複習 XD。</p>\n<hr>\n<h1 id=\"前言\">前言</h1>\n<p><code>var</code>、<code>let</code> 以及 <code>const</code> 都是在 JavaScript 用來做變數宣告的保留字，在 JavaScript 早期只有 <code>var</code>，直到 ES6 時才加入了 <code>let</code> 與 <code>const</code> 。</p>\n<p>這次，我將分別根據<strong>作用域</strong>、<strong>用途</strong>、以及<strong>提升</strong>（Hoisting）等特性來說明它們的不同。</p>\n<h1 id=\"作用域的差別\">作用域的差別</h1>\n<p>什麼是作用域（Scope）？先來看看 <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Scope\">MDN</a> 的解釋：</p>\n<blockquote>\n<p>The current context of execution. The context in which values and expressions are “visible” or can be referenced. If a variable or other expression is not “in the current scope,” then it is unavailable for use. Scopes can also be layered in a hierarchy, so that child scopes have access to parent scopes, but not vice versa.</p>\n</blockquote>\n<p>如果上面這段話你可以看得懂，那麼恭喜你，你的功力簡直比我還深厚（<s>誤</s>）。</p>\n<blockquote>\n<p>💡 <strong>提示</strong></p>\n<p>簡單翻譯上面的定義：作用域是指一個值（value）或一個表達式（expression）使用上的<strong>有效範圍或可以被存取的範圍</strong>。</p>\n</blockquote>\n<p>JavaScript 擁有以下三種作用域：</p>\n<ul>\n<li>\n<p>全域作用域（Global Scope）</p>\n</li>\n<li>\n<p>函式作用域（Function Scope）</p>\n</li>\n<li>\n<p>區塊作用域（Block Scope）（也是 ES6 發展出的新特性）</p>\n</li>\n</ul>\n<h2 id=\"一全域作用域\"><strong>一、全域作用域</strong></h2>\n<p>是 JavaScript 作用域的最外層，定義在全域中的變數，能夠在程式碼中的任何地方被使用，本文的主角之一 <code>var</code> 就具備全域作用域。</p>\n<p>當我們在一個文件的最外層使用 <code>var</code> 來宣告變數，這時它的範圍會是全域，可以來看看下面的栗子🌰：</p>\n<pre class=\"astro-code ayu-dark\" style=\"background-color:#0b0e14;color:#bfbdb6; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#FF8F40\">var</span><span style=\"color:#BFBDB6\"> a </span><span style=\"color:#F29668\">=</span><span style=\"color:#AAD94C\"> \"我是全域變數\"</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#FF8F40\">function</span><span style=\"color:#FFB454\"> call</span><span style=\"color:#BFBDB6\">() {</span></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">  console</span><span style=\"color:#F29668\">.</span><span style=\"color:#FFB454\">log</span><span style=\"color:#BFBDB6\">(a)</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#FFB454\">call</span><span style=\"color:#BFBDB6\">()</span><span style=\"color:#BFBDB6B3\">;</span><span style=\"color:#ACB6BF8C;font-style:italic\"> // 我是全域變數</span></span>\n<span class=\"line\"></span></code></pre>\n<p>第一行在最外層用 <code>var</code> 來宣告變數，因此變數 a 在函式裡面就可以被訪問到，也能順利印出「我是全域變數」這個字串。</p>\n<h2 id=\"二函式作用域\">二、函式作用域</h2>\n<p>亦即在函式中宣告的變數，有效作用範圍會被限制在該函式中。</p>\n<pre class=\"astro-code ayu-dark\" style=\"background-color:#0b0e14;color:#bfbdb6; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#FF8F40\">function</span><span style=\"color:#FFB454\"> scope</span><span style=\"color:#BFBDB6\">() {</span></span>\n<span class=\"line\"><span style=\"color:#FF8F40\">  let</span><span style=\"color:#BFBDB6\"> a </span><span style=\"color:#F29668\">=</span><span style=\"color:#AAD94C\"> \"函式作用域\"</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">  console</span><span style=\"color:#F29668\">.</span><span style=\"color:#FFB454\">log</span><span style=\"color:#BFBDB6\">(a)</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#FFB454\">scope</span><span style=\"color:#BFBDB6\">()</span><span style=\"color:#BFBDB6B3\">;</span><span style=\"color:#ACB6BF8C;font-style:italic\"> // 函式作用域</span></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">console</span><span style=\"color:#F29668\">.</span><span style=\"color:#FFB454\">log</span><span style=\"color:#BFBDB6\">(a)</span><span style=\"color:#BFBDB6B3\">;</span><span style=\"color:#ACB6BF8C;font-style:italic\"> // Uncaught ReferenceError: a is not defined</span></span>\n<span class=\"line\"></span></code></pre>\n<p>我們在函式內用 <code>let</code> 宣告一個變數，呼叫函式時理所當然地能夠被印出；然而一旦在函式外面嘗試存取此變數（如第 7 行所示），便會執行失敗。</p>\n<h2 id=\"三區塊作用域\">三、區塊作用域</h2>\n<p>被定義在一個由 <code>{}</code> 大括號包起來的區塊，舉凡 if、for、switch、while 等等，都可以界定出作用範圍。</p>\n<p>要注意的是，<strong>只有</strong> <code>let</code> 和 <code>const</code> 定義的變數會屬於區塊作用域。</p>\n<p>來看底下這段範例，如果是使用 <code>var</code> 來定義變數，程式碼中的變數 a 並不是在函式中定義的，所以會變為「全域變數」；然而如果是使用 <code>let</code> 來宣告的變數 b，則無法在外部環境中取得。</p>\n<pre class=\"astro-code ayu-dark\" style=\"background-color:#0b0e14;color:#bfbdb6; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#FF8F40\">if</span><span style=\"color:#BFBDB6\"> (</span><span style=\"color:#D2A6FF\">true</span><span style=\"color:#BFBDB6\">) {</span></span>\n<span class=\"line\"><span style=\"color:#FF8F40\">    var</span><span style=\"color:#BFBDB6\"> a </span><span style=\"color:#F29668\">=</span><span style=\"color:#AAD94C\"> \"全域作用域\"</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"><span style=\"color:#FF8F40\">    let</span><span style=\"color:#BFBDB6\"> b </span><span style=\"color:#F29668\">=</span><span style=\"color:#AAD94C\"> \"區塊作用域\"</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">console</span><span style=\"color:#F29668\">.</span><span style=\"color:#FFB454\">log</span><span style=\"color:#BFBDB6\">(a)</span><span style=\"color:#BFBDB6B3\">;</span><span style=\"color:#ACB6BF8C;font-style:italic\"> // 全域作用域</span></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">console</span><span style=\"color:#F29668\">.</span><span style=\"color:#FFB454\">log</span><span style=\"color:#BFBDB6\">(b)</span><span style=\"color:#BFBDB6B3\">;</span><span style=\"color:#ACB6BF8C;font-style:italic\"> // Uncaught ReferenceError: b is not defined</span></span>\n<span class=\"line\"></span></code></pre>\n<p><code>var</code> 具備了全域作用域及函式作用域，<mark>但不具有區塊作用域，所以在區塊中宣告的變數，依然會作用到區塊之外，並不會被區塊限制住</mark>。</p>\n<h3 id=\"補充全域變數的汙染\">補充：全域變數的汙染</h3>\n<pre class=\"astro-code ayu-dark\" style=\"background-color:#0b0e14;color:#bfbdb6; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#FF8F40\">for</span><span style=\"color:#BFBDB6\"> (</span><span style=\"color:#FF8F40\">var</span><span style=\"color:#BFBDB6\"> i </span><span style=\"color:#F29668\">=</span><span style=\"color:#D2A6FF\"> 0</span><span style=\"color:#BFBDB6B3\">;</span><span style=\"color:#BFBDB6\"> i </span><span style=\"color:#F29668\">&#x3C;</span><span style=\"color:#D2A6FF\"> 3</span><span style=\"color:#BFBDB6B3\">;</span><span style=\"color:#BFBDB6\"> i </span><span style=\"color:#F29668\">++</span><span style=\"color:#BFBDB6\">) {</span></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">    console</span><span style=\"color:#F29668\">.</span><span style=\"color:#FFB454\">log</span><span style=\"color:#BFBDB6\">(i)</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">console</span><span style=\"color:#F29668\">.</span><span style=\"color:#FFB454\">log</span><span style=\"color:#BFBDB6\">(window</span><span style=\"color:#F29668\">.</span><span style=\"color:#BFBDB6\">i)</span><span style=\"color:#BFBDB6B3\">;</span><span style=\"color:#ACB6BF8C;font-style:italic\"> // 3</span></span>\n<span class=\"line\"></span></code></pre>\n<p>如果我們在 for 迴圈裡用 <code>var</code> 來宣告變數 i ，則這個值也會被紀錄在 window 裡，變成一個全域變數，無形之中汙染到了全域變數。</p>\n<h1 id=\"用途的差別\">用途的差別</h1>\n<p>不囉嗦，先上個程式碼當範例：</p>\n<pre class=\"astro-code ayu-dark\" style=\"background-color:#0b0e14;color:#bfbdb6; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#FF8F40\">var</span><span style=\"color:#BFBDB6\"> greeter </span><span style=\"color:#F29668\">=</span><span style=\"color:#AAD94C\"> \"Hi :)\"</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"><span style=\"color:#FF8F40\">var</span><span style=\"color:#BFBDB6\"> greeter </span><span style=\"color:#F29668\">=</span><span style=\"color:#AAD94C\"> \"Say hello instead\"</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">console</span><span style=\"color:#F29668\">.</span><span style=\"color:#FFB454\">log</span><span style=\"color:#BFBDB6\">(greeter)</span><span style=\"color:#BFBDB6B3\">;</span><span style=\"color:#ACB6BF8C;font-style:italic\"> // Say hello instead</span></span>\n<span class=\"line\"></span></code></pre>\n<p>可以發現原本第一行的宣告的變數被覆蓋掉了，會造成這個結果是因為 <code>var</code> 可以重複宣告。而 <code>let</code> <strong>可以重新賦值，但不能重複宣告</strong>，所以會如下面這樣：</p>\n<pre class=\"astro-code ayu-dark\" style=\"background-color:#0b0e14;color:#bfbdb6; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#FF8F40\">let</span><span style=\"color:#BFBDB6\"> greeter </span><span style=\"color:#F29668\">=</span><span style=\"color:#AAD94C\"> \"Hi :)\"</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"><span style=\"color:#FF8F40\">let</span><span style=\"color:#BFBDB6\"> greeter </span><span style=\"color:#F29668\">=</span><span style=\"color:#AAD94C\"> \"Say hello instead\"</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">console</span><span style=\"color:#F29668\">.</span><span style=\"color:#FFB454\">log</span><span style=\"color:#BFBDB6\">(greeter)</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"><span style=\"color:#ACB6BF8C;font-style:italic\">// Uncaught SyntaxError: Identifier 'greeter' has already been declared</span></span>\n<span class=\"line\"></span></code></pre>\n<p>但如果換成下面這種方法就可以：</p>\n<pre class=\"astro-code ayu-dark\" style=\"background-color:#0b0e14;color:#bfbdb6; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#FF8F40\">let</span><span style=\"color:#BFBDB6\"> greeter </span><span style=\"color:#F29668\">=</span><span style=\"color:#AAD94C\"> \"Hi :)\"</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">greeter </span><span style=\"color:#F29668\">=</span><span style=\"color:#AAD94C\"> \"Say 你好 instead :)\"</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#BFBDB6\">console</span><span style=\"color:#F29668\">.</span><span style=\"color:#FFB454\">log</span><span style=\"color:#BFBDB6\">(greeter)</span><span style=\"color:#BFBDB6B3\">;</span><span style=\"color:#ACB6BF8C;font-style:italic\"> // Say 你好 instead :)</span></span>\n<span class=\"line\"></span></code></pre>\n<p>至於 <code>const</code>，是更嚴謹的宣告變數，其實 const 是常數「Constant」縮寫而來的，所以顧名思義 const 就是宣告常數的意思，無法被重新宣告、更無法被重新賦值哦！</p>\n<h1 id=\"提升hoisting的差別\">提升（Hoisting）的差別</h1>\n<p>Hoisting 這個主題也是 JS 裡面數一數二困擾的，我也蠻感興趣的，正打算改天再另外寫一篇文來講解，因此這篇不會著墨太多 Hositing 的特性，如果想了解的也可以先看<a href=\"https://blog.techbridge.cc/2018/11/10/javascript-hoisting/\">這篇</a>。</p>\n<p>目前我們只需要知道：</p>\n<blockquote>\n<p>💡 <strong>提示</strong></p>\n<p>Javascript 在程式的編譯階段，會先把宣告的變數和函式放在程式的頂端，等到實際執行時在賦予其值。</p>\n</blockquote>\n<p>注意這邊指的是一個概念上的提升，並不代表 JS 在編譯時會真的去更動程式碼的位置。</p>\n<p>其中又因為 <code>var</code> 有著「提升」的特性，會造成以下這種弔詭的情況：</p>\n<pre class=\"astro-code ayu-dark\" style=\"background-color:#0b0e14;color:#bfbdb6; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#BFBDB6\">console</span><span style=\"color:#F29668\">.</span><span style=\"color:#FFB454\">log</span><span style=\"color:#BFBDB6\">(i)</span><span style=\"color:#BFBDB6B3\">;</span><span style=\"color:#ACB6BF8C;font-style:italic\"> // undefined</span></span>\n<span class=\"line\"><span style=\"color:#FF8F40\">var</span><span style=\"color:#BFBDB6\"> i </span><span style=\"color:#F29668\">=</span><span style=\"color:#D2A6FF\"> 5</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"></span></code></pre>\n<p>會印出 undefined 即是代表：雖然我們看不見，但其實在 <code>console.log(i)</code> 之前，i 就已經被宣告了，只是尚未賦值。</p>\n<p>但是 <code>let</code> 與 <code>const</code> 則不會，而是會進到<a href=\"https://www.freecodecamp.org/news/what-is-the-temporal-dead-zone/\">暫時死區 (TDZ)</a>，因此在 <code>let</code> 與 <code>const</code> 宣告變數前使用該變數，會出現錯誤：</p>\n<pre class=\"astro-code ayu-dark\" style=\"background-color:#0b0e14;color:#bfbdb6; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#BFBDB6\">console</span><span style=\"color:#F29668\">.</span><span style=\"color:#FFB454\">log</span><span style=\"color:#BFBDB6\">(i)</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"><span style=\"color:#FF8F40\">let</span><span style=\"color:#BFBDB6\"> i </span><span style=\"color:#F29668\">=</span><span style=\"color:#D2A6FF\"> 5</span><span style=\"color:#BFBDB6B3\">;</span></span>\n<span class=\"line\"><span style=\"color:#ACB6BF8C;font-style:italic\">// Uncaught ReferenceError: Cannot access 'i' before initialization</span></span>\n<span class=\"line\"></span></code></pre>\n<hr>\n<p>以上就是這次的「淺談 var、let 與 const 的差異」，希望會你們有幫助，也希望下次自己不要再忘記這些觀念了！</p>\n<p>Reference：</p>\n<blockquote>\n<p><a href=\"https://www.explainthis.io/zh-hant/swe/what-is-scope-and-scope-chain\">Javascript 的作用域 (Scope) 與作用域鏈 (Scope Chain) 是什麼?</a> <br>\n<a href=\"https://www.explainthis.io/zh-hant/swe/js-var-let-const-in-javascript\">在 JavaScript 中用 var, let, 以及 const 有什麼差別？什麼時候該用哪個？</a> <br>\n<a href=\"https://www.programfarmer.com/articles/2020/javascript-var-let-const-for-loop\">JS 宣告變數， var 與 let / const 差異</a> <br>\n<a href=\"https://www.freecodecamp.org/chinese/news/javascript-var-let-and-const/\">JavaScript 中的 Var、Let 和 Const 有什么区别</a> <br>\n<a href=\"https://hackmd.io/@bookbasketball/SJ1lqTzSt\">[JavaScript] 談var、let、const差異之var你這個矯情的賤人</a></p>\n</blockquote>\n<pre class=\"astro-code ayu-dark\" style=\"background-color:#0b0e14;color:#bfbdb6; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>有任何想法想分享或協助勘誤，歡迎留言交流指教！🐰</span></span>\n<span class=\"line\"><span></span></span></code></pre>";

				const frontmatter = {"title":"JS 變數宣告：淺談 var、let、const 的差異","pubDate":"2024-03-05T00:00:00.000Z","tags":["JavaScript"],"categories":["Frontend"]};
				const file = "/Users/millieqiu/MillieDev/millie-blog/src/content/posts/frontend-js-var-let-const.md";
				const url = undefined;
				function rawContent() {
					return "\n會想寫這篇文的原因，是某天跟同事聊天的過程中，聊到在 JS 宣告變數時幾乎很少用到 `var`，雖然知道這種宣告變數的方式跟 `let`、`const` 有差異，具體而言我卻說不出為什麼，只依稀記得跟作用域有關......。\n\n為了往後討論這個問題時，都能像個 JS 大師般侃侃而談，我回家後立刻將這題好好鑽研一番，也順便做了筆記，如果以後忘記了隨時都能拿出來複習 XD。\n\n---\n\n# 前言\n\n`var`、`let` 以及 `const` 都是在 JavaScript 用來做變數宣告的保留字，在 JavaScript 早期只有 `var`，直到 ES6 時才加入了 `let` 與 `const` 。\n\n這次，我將分別根據**作用域**、**用途**、以及**提升**（Hoisting）等特性來說明它們的不同。\n\n# 作用域的差別\n\n什麼是作用域（Scope）？先來看看 [MDN](https://developer.mozilla.org/en-US/docs/Glossary/Scope) 的解釋：\n\n> The current context of execution. The context in which values and expressions are “visible” or can be referenced. If a variable or other expression is not “in the current scope,” then it is unavailable for use. Scopes can also be layered in a hierarchy, so that child scopes have access to parent scopes, but not vice versa.\n\n如果上面這段話你可以看得懂，那麼恭喜你，你的功力簡直比我還深厚（<s>誤</s>）。\n\n> 💡 **提示**\n>\n> 簡單翻譯上面的定義：作用域是指一個值（value）或一個表達式（expression）使用上的**有效範圍或可以被存取的範圍**。\n\nJavaScript 擁有以下三種作用域：\n\n* 全域作用域（Global Scope）\n\n* 函式作用域（Function Scope）\n\n* 區塊作用域（Block Scope）（也是 ES6 發展出的新特性）\n\n## **一、全域作用域**\n\n是 JavaScript 作用域的最外層，定義在全域中的變數，能夠在程式碼中的任何地方被使用，本文的主角之一 `var` 就具備全域作用域。\n\n當我們在一個文件的最外層使用 `var` 來宣告變數，這時它的範圍會是全域，可以來看看下面的栗子🌰：\n\n```javascript\nvar a = \"我是全域變數\";\n\nfunction call() {\n  console.log(a);\n}\n\ncall(); // 我是全域變數\n```\n\n第一行在最外層用 `var` 來宣告變數，因此變數 a 在函式裡面就可以被訪問到，也能順利印出「我是全域變數」這個字串。\n\n## 二、函式作用域\n\n亦即在函式中宣告的變數，有效作用範圍會被限制在該函式中。\n\n```javascript\nfunction scope() {\n  let a = \"函式作用域\";\n  console.log(a);\n}\n\nscope(); // 函式作用域\nconsole.log(a); // Uncaught ReferenceError: a is not defined\n```\n\n我們在函式內用 `let` 宣告一個變數，呼叫函式時理所當然地能夠被印出；然而一旦在函式外面嘗試存取此變數（如第 7 行所示），便會執行失敗。\n\n## 三、區塊作用域\n\n被定義在一個由 `{}` 大括號包起來的區塊，舉凡 if、for、switch、while 等等，都可以界定出作用範圍。\n\n要注意的是，**只有** `let` 和 `const` 定義的變數會屬於區塊作用域。\n\n來看底下這段範例，如果是使用 `var` 來定義變數，程式碼中的變數 a 並不是在函式中定義的，所以會變為「全域變數」；然而如果是使用 `let` 來宣告的變數 b，則無法在外部環境中取得。\n\n```javascript\nif (true) {\n    var a = \"全域作用域\";\n    let b = \"區塊作用域\";\n}\n\nconsole.log(a); // 全域作用域\nconsole.log(b); // Uncaught ReferenceError: b is not defined\n```\n\n`var` 具備了全域作用域及函式作用域，<mark>但不具有區塊作用域，所以在區塊中宣告的變數，依然會作用到區塊之外，並不會被區塊限制住</mark>。\n\n### 補充：全域變數的汙染\n\n```javascript\nfor (var i = 0; i < 3; i ++) {\n    console.log(i);\n}\n\nconsole.log(window.i); // 3\n```\n\n如果我們在 for 迴圈裡用 `var` 來宣告變數 i ，則這個值也會被紀錄在 window 裡，變成一個全域變數，無形之中汙染到了全域變數。\n\n# 用途的差別\n\n不囉嗦，先上個程式碼當範例：\n\n```javascript\nvar greeter = \"Hi :)\";\nvar greeter = \"Say hello instead\";\n\nconsole.log(greeter); // Say hello instead\n```\n\n可以發現原本第一行的宣告的變數被覆蓋掉了，會造成這個結果是因為 `var` 可以重複宣告。而 `let` **可以重新賦值，但不能重複宣告**，所以會如下面這樣：\n\n```javascript\nlet greeter = \"Hi :)\";\nlet greeter = \"Say hello instead\";\n\nconsole.log(greeter);\n// Uncaught SyntaxError: Identifier 'greeter' has already been declared\n```\n\n但如果換成下面這種方法就可以：\n\n```javascript\nlet greeter = \"Hi :)\";\ngreeter = \"Say 你好 instead :)\";\n\nconsole.log(greeter); // Say 你好 instead :)\n```\n\n至於 `const`，是更嚴謹的宣告變數，其實 const 是常數「Constant」縮寫而來的，所以顧名思義 const 就是宣告常數的意思，無法被重新宣告、更無法被重新賦值哦！\n\n# 提升（Hoisting）的差別\n\nHoisting 這個主題也是 JS 裡面數一數二困擾的，我也蠻感興趣的，正打算改天再另外寫一篇文來講解，因此這篇不會著墨太多 Hositing 的特性，如果想了解的也可以先看[這篇](https://blog.techbridge.cc/2018/11/10/javascript-hoisting/)。\n\n目前我們只需要知道：\n\n> 💡 **提示**\n>\n> Javascript 在程式的編譯階段，會先把宣告的變數和函式放在程式的頂端，等到實際執行時在賦予其值。\n\n注意這邊指的是一個概念上的提升，並不代表 JS 在編譯時會真的去更動程式碼的位置。\n\n其中又因為 `var` 有著「提升」的特性，會造成以下這種弔詭的情況：\n\n```javascript\nconsole.log(i); // undefined\nvar i = 5;\n```\n\n會印出 undefined 即是代表：雖然我們看不見，但其實在 `console.log(i)` 之前，i 就已經被宣告了，只是尚未賦值。\n\n但是 `let` 與 `const` 則不會，而是會進到[暫時死區 (TDZ)](https://www.freecodecamp.org/news/what-is-the-temporal-dead-zone/)，因此在 `let` 與 `const` 宣告變數前使用該變數，會出現錯誤：\n\n```javascript\nconsole.log(i);\nlet i = 5;\n// Uncaught ReferenceError: Cannot access 'i' before initialization\n```\n\n---\n\n以上就是這次的「淺談 var、let 與 const 的差異」，希望會你們有幫助，也希望下次自己不要再忘記這些觀念了！\n\nReference：\n\n> [Javascript 的作用域 (Scope) 與作用域鏈 (Scope Chain) 是什麼?](https://www.explainthis.io/zh-hant/swe/what-is-scope-and-scope-chain) <br>\n> [在 JavaScript 中用 var, let, 以及 const 有什麼差別？什麼時候該用哪個？](https://www.explainthis.io/zh-hant/swe/js-var-let-const-in-javascript) <br>\n> [JS 宣告變數， var 與 let / const 差異](https://www.programfarmer.com/articles/2020/javascript-var-let-const-for-loop) <br>\n>[JavaScript 中的 Var、Let 和 Const 有什么区别](https://www.freecodecamp.org/chinese/news/javascript-var-let-and-const/) <br>\n> [\\[JavaScript\\] 談var、let、const差異之var你這個矯情的賤人](https://hackmd.io/@bookbasketball/SJ1lqTzSt)\n\n```plaintext\n有任何想法想分享或協助勘誤，歡迎留言交流指教！🐰\n```";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":1,"slug":"前言","text":"前言"},{"depth":1,"slug":"作用域的差別","text":"作用域的差別"},{"depth":2,"slug":"一全域作用域","text":"一、全域作用域"},{"depth":2,"slug":"二函式作用域","text":"二、函式作用域"},{"depth":2,"slug":"三區塊作用域","text":"三、區塊作用域"},{"depth":3,"slug":"補充全域變數的汙染","text":"補充：全域變數的汙染"},{"depth":1,"slug":"用途的差別","text":"用途的差別"},{"depth":1,"slug":"提升hoisting的差別","text":"提升（Hoisting）的差別"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
